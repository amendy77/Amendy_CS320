How can I ensure that my code, program, or software is functional and secure?

  Making sure that code is both secure and functional can be difficult. To make sure everything functions, I have only tested the code so far in this course, which was a touch excessive in some situations. 
  It wasn't until I took this class that I realized how involved this was. I can make sure my code is safe and works by following the specifications and creating comprehensive tests that, when run, yield a high coverage percentage. 
  I tested repeatedly until my coverage percentages for this class were at least 90% in order to do this. The main steps in ensuring that the code is functional are to follow the requirements and write comprehensive tests
  based on the requirements to ensure that the code is secure.

How do I interpret user needs and incorporate them into a program?

  I initially read user requirements before decomposing them into components that will or won't operate with a program. One instance that springs to mind is the limitations imposed on the maximum length and blank submissions.
  First, there were names that had to be at least 10 characters long and could not be null. After reading that,I used an if statement to cover both of the failure alternatives and implemented that into the application. 
  This is a simple method of turning a demand into a program since it converts the need straight into a success condition. Sometimes the requirements are more vague and necessitate further investigation. One program I had in another class needed
  that it be able to add time to two independent clocks with the press of a button. That was thoroughly broken down into a program, but not in the same way because you had a general requirement,
  but it wasn't as simple as making an illegal argument exception.

How do I approach designing software?

My approach to software design could use some improvement. I usually look at the requirements documents or interview transcripts, if that option is chosen, and build a checklist of requirements.
These needs are then broken down, if relevant, into a list of objects required to complete this task, followed by the necessary methods. Then, having my numerous lists in hand, I start developing the code to fulfill those needs.
Once the code is functional, I go back over it and make it more efficient wherever possible. 
So far, it has been a rather productive way for me in my studies, but I could benefit from a more comprehensive and in-depth approach.
